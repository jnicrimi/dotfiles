# local-review

## 概要

ローカルリポジトリ内の変更（ベースブランチとの差分、または未コミットの変更）を分析し、コードレビューを実施する対話型コマンドです。

## 実行手順

### 1. 思考レベルの選択

レビューの詳細度を選択できます。以下のオプションから番号を選択してもらってください：

```text
思考レベルを選択してください：
1. ⭐ Basic (基本) - 素早い基本的なレビュー
2. ⭐⭐ Detailed (詳細) - 詳細な分析とレビュー
3. ⭐⭐⭐ Deep (深層) - 最も詳細な多角的レビュー

選択してください:
```

- ユーザーが番号を選択したら、対応する思考レベルを記録してください
- 1-3以外が入力された場合は「無効な番号です。もう一度番号を入力してください」と再入力を促してください

### 2. 現在の状態確認

- 現在のブランチと作業状況を把握してください

```bash
# 現在のブランチを確認
git branch --show-current

# 未コミットの変更を確認
git status --short
```

### 3. レビュー対象の選択

```bash
# 1. 現在のブランチ以外のローカルブランチを取得
git branch | grep -v '^\*' | sed 's/^  //'

# 2. 未コミットの変更を確認
git status --short
```

- 他のローカルブランチまたは未コミットの変更が存在する場合：
  - 番号付きリストでレビュー対象を表示してください
  - リストの最後に「未コミットの変更」オプションを追加してください
  - ユーザーが番号を選択したら、対応する差分を調査してください（選択は排他的で、いずれか1つのみ）
  - 候補にない番号が入力された場合は「無効な番号です。もう一度番号を入力してください」と再入力を促してください
- どちらも存在しない場合：
  - 「レビュー可能な変更がありません。」と表示して処理を終了してください

### 4. 差分の調査と分析

選択に応じて差分を調査し、以下の情報を収集してください：

#### ベースブランチが選択された場合

- `${selected_branch}` に <選択されたベースブランチ名> を設定します
- `${review_target}` に 「対象のブランチ: <選択されたベースブランチ名>」を設定します

```bash
# 1. 差分の統計情報を取得
git diff ${selected_branch}...HEAD --stat

# 2. 変更されたファイル一覧を取得
git diff ${selected_branch}...HEAD --name-status

# 3. 実際の差分内容を取得して分析
git diff ${selected_branch}...HEAD
```

#### 「未コミットの変更」が選択された場合

- `${selected_branch}` は設定しません
- `${review_target}` に「対象: 未コミットの変更」を設定します

```bash
# 1. 変更の統計情報を取得（レビュー対象の範囲と影響度を把握するため）
git diff --staged --stat
git diff --stat

# 2. ステージされた変更を確認
git diff --staged

# 3. ステージされていない変更を確認
git diff

# 4. 変更ファイルの一覧
git status --short
```

収集した情報をもとに、以下を理解してください：

- 現在のブランチで追加/変更された機能
- ベースブランチから分岐後の変更内容
- 未コミットの変更内容
- レビューで注意すべき変更点

### 5. レビュー観点の整理

#### レビューチェックリスト（内部参照用）

以下の観点でレビューを実施してください：

##### 重要度の判断基準

- **🟥 Critical (必須修正)**: セキュリティ脆弱性、データ損失リスク、システム停止を引き起こす問題
- **🟧 Major (要対応)**: 不具合、不足している必須機能、パフォーマンス問題
- **🟨 Minor (軽微な問題)**: コードスタイルの違反、軽微な問題
- **🟩 Good (優れた実装)**: 優れた実装、適切なエラーハンドリング、良い設計判断

##### 影響範囲の分析

- [ ] 変更されたクラス/関数を使用している箇所への影響
- [ ] インターフェースや型定義の変更による型エラーの可能性
- [ ] 削除・名前変更されたコードを参照している箇所の有無
- [ ] import/exportの変更による依存関係への影響
- [ ] 破壊的変更（Breaking Changes）の有無

##### 実装の完全性と一貫性

- [ ] 実装に不完全な箇所はないか（TODO、FIXME、未実装メソッド）
- [ ] エッジケースが考慮されているか
- [ ] エラーハンドリングが適切か
- [ ] 同様の処理パターンと一貫性があるか
- [ ] データ型の一貫性（型変換の安全性、null/undefinedの処理）

##### コード品質

- [ ] 命名規則に従っているか
- [ ] 重複コードはないか
- [ ] 設定値・定数のハードコーディングがないか（マジックナンバー、環境依存値）

##### パフォーマンス

- [ ] 不要な処理はないか
- [ ] リソースの解放は適切か

##### セキュリティ

- [ ] 入力値検証が実装されているか
- [ ] 機密情報の取り扱いが適切か
- [ ] 脆弱性につながる実装はないか
- [ ] ログ出力の適切性（デバッグログの削除、機密情報の非出力）

##### テスト

- [ ] 追加/変更された関数・メソッドに対応するテストが存在するか
- [ ] 重要な分岐条件やエラーケースがテストされているか
- [ ] 既存のテストが削除・無効化されていないか

### エージェントの使用

code-reviewerエージェントを使用して、レビューチェックリストの観点を含む専門的な分析を実施します。

エージェントは選択された思考レベルに応じて以下の深度で分析を行います：

- **Level 1 (Basic)**: 基本的なコード品質とエラーチェック
- **Level 2 (Detailed)**: 詳細な設計パターンとベストプラクティスの確認
- **Level 3 (Deep)**: アーキテクチャレベルの分析とセキュリティ監査

### 6. レビュー結果の出力

以下のルールに従って出力してください：

**出力ルール:**

- テンプレートの内容のみを出力する
- テキスト形式で出力する（```text```ブロックで囲む）
- レビューチェックリストは出力しない（内部参照用）
- テンプレート以外の説明や補足は追加しない
- 角括弧で始まる指示行（例: `[選択された…]`）は出力しない
- 「例: …」と示された例示行は実データに置き換えるか、該当がなければ出力しない
- `${...}` の変数は実データで置き換える（未取得の場合は「なし」等の明示語に置換）
- `[...]` のプレースホルダはAIが適切な内容を生成して置き換える

**出力テンプレート:**

```text
========================================
📊 レビュー概要
========================================

思考レベル: [選択されたレベル] 例: ⭐⭐ Detailed (詳細)
────────────────────────────────────────

📝 変更情報
────────────────────────────────────────
• 現在のブランチ: ${current_branch}
• ${review_target}
• 変更統計: [統計情報] 例: 5ファイル変更（+120行、-45行）

🔍 指摘事項（概要）
────────────────────────────────────────

🟥 Critical Issues ([件数])
[必須修正が必要な重大な問題の概要リスト]
例: • SQL注入の脆弱性

🟧 Major Issues ([件数])
[要対応の問題の概要リスト]
例: • エラー処理の不足

🟨 Minor Issues ([件数])
[軽微な問題の概要リスト]
例: • 未使用の変数

🟩 Good Practices ([件数])
[優れた実装や良い点の概要リスト]
例: • 適切なエラーハンドリング

💡 改善提案（概要）
────────────────────────────────────────
• [リファクタリング提案の概要]
例: • 重複コードの抽出を推奨
• [パフォーマンス最適化案の概要]
例: • ループ処理の最適化を推奨
• [コード簡潔化の提案の概要]
例: • 条件式の簡潔化を推奨
• [ベストプラクティスの適用提案の概要]
例: • async/awaitパターンへの移行を推奨

========================================
🔍 指摘事項（詳細）
========================================

🟥 Critical Issues
────────────────────────────────────────
[各Critical Issueの詳細説明]

◆ [問題タイトル]
例: ◆ SQL注入の脆弱性
• ファイル: [ファイル名:行番号]
例: • ファイル: database.js:42
• 問題内容: [詳細な問題の説明]
例: • 問題内容: user_inputを直接SQLクエリに埋め込んでおり、SQLインジェクション攻撃を受ける可能性がある
• 影響範囲: [この問題による影響]
例: • 影響範囲: データベースの不正操作、情報漏洩、データの改ざんリスク
• 修正方法: [推奨される修正方法]
例: • 修正方法: プリペアドステートメントを使用するか、入力値のサニタイズを実装する

🟧 Major Issues
────────────────────────────────────────
[各Major Issueの詳細説明]

◆ [問題タイトル]
例: ◆ エラー処理の不足
• ファイル: [ファイル名:行番号]
例: • ファイル: api.js:78
• 問題内容: [詳細な問題の説明]
例: • 問題内容: API呼び出し失敗時のエラーハンドリングが実装されていない
• 影響範囲: [この問題による影響]
例: • 影響範囲: アプリケーションのクラッシュ、ユーザー体験の低下
• 修正方法: [推奨される修正方法]
例: • 修正方法: try-catchブロックを追加し、適切なエラーメッセージを表示

🟨 Minor Issues
────────────────────────────────────────
[各Minor Issueの詳細説明]

◆ [問題タイトル]
例: ◆ 未使用の変数
• ファイル: [ファイル名:行番号]
例: • ファイル: utils.js:15
• 問題内容: [詳細な問題の説明]
例: • 問題内容: 'tempData'変数が定義されているが、コード内で使用されていない
• 修正方法: [推奨される修正方法]
例: • 修正方法: 変数を削除するか、必要であれば使用する処理を追加

🟩 Good Practices
────────────────────────────────────────
[各Good Practiceの詳細説明]

◆ [良い実装のタイトル]
例: ◆ 適切なエラーハンドリング
• ファイル: [ファイル名:行番号]
例: • ファイル: main.js:120-135
• 内容: [優れた実装の詳細説明]
例: • 内容: try-catchブロックで全ての例外を適切に捕捉し、ユーザーフレンドリーなエラーメッセージを表示している
• 評価理由: [なぜこれが良い実装なのか]
例: • 評価理由: エラー時でもアプリケーションが安定して動作し、ユーザーが問題を理解しやすい

========================================
💡 改善提案（詳細）
========================================

[各改善提案の詳細説明]

◆ [提案タイトル]
例: ◆ 重複コードの抽出
• 対象箇所: [該当するファイルや関数]
例: • 対象箇所: processUser()とprocessAdmin()関数
• 提案理由: [なぜこの改善が必要か]
例: • 提案理由: 同じロジックが複数箇所に存在し、保守性が低下している
• 期待効果: [改善による効果]
例: • 期待効果: コードの重複削減、保守性向上、バグ発生リスクの低減

◆ [提案タイトル]
例: ◆ パフォーマンス最適化
• 対象箇所: [該当するファイルや関数]
例: • 対象箇所: データ処理ループ (main.js:200-250)
• 提案理由: [なぜこの改善が必要か]
例: • 提案理由: forループ内で繰り返しDOM操作を行っており、パフォーマンスが低下
• 期待効果: [改善による効果]
例: • 期待効果: 処理速度の向上、レンダリング回数の削減
